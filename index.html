<!DOCTYPE html>
<!-- original author from ika-udon ,others from Leersxie-->
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>scratch波形生成工具</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 使用的字体 */
        body {
            font-family: "Inter", sans-serif;
            background-color: #1a202c; /* 深色背景颜色 */
            color: #e2e8f0; /* 明亮的文本颜色 */
            display: flex;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            box-sizing: border-box;
            position: relative;
        }
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }
        canvas {
            background-color: #2d3748; /* 画布的背景色 */
            border-radius: 0.5rem; /* 圆角处理 */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 添加阴影 */
            display: block;
            width: 100%; /* 主元素决定宽度 */
            max-width: 800px; /* 最大幅幅度定 */
            height: 300px; /* 固定高度 */
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
        }
        input[type="file"] {
            display: none; /* 隐藏默认的文件输入按钮 */
        }
        .custom-file-upload {
            background-color: #4a5568; /* 按钮的颜色 */
            color: #e2e8f0; /* 按钮的文本颜色 */
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border: 2px solid #6b7280; /* 按钮边框 */
        }
        .custom-file-upload:hover {
            background-color: #6b7280; /* 鼠标悬停时的背景色 */
        }
        audio {
            width: 100%;
            max-width: 800px;
            margin-top: 1rem;
            border-radius: 0.5rem;
        }
        .setting-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: 100%; /* 网格项中占据宽度 */
        }
        .setting-item label {
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
            color: #cbd5e0;
        }
        .setting-item input[type="number"],
        .setting-item input[type="color"] { /* 为颜色选择器添加样式 */
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            background-color: #4a5568;
            border: 1px solid #6b7280;
            color: #e2e8f0;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .setting-item input[type="number"]:focus,
        .setting-item input[type="color"]:focus {
            border-color: #63b3ed;
            box-shadow: 0 0 0 2px rgba(99, 179, 237, 0.5);
        }
        /* 调整颜色拾取器的默认填充 */
        .setting-item input[type="color"] {
            padding: 0.2rem; /* 缩小样品，放大颜色样本 */
            height: 40px; /* 确保高度 */
        }
        
        .log-container {
            width: 300px;
            background-color: #2d3748;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            margin-left: 1rem;
            position: fixed; /* 固定配置更改 */
            top: 1rem;
            right: 1rem;
            height: calc(100vh - 2rem);
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            opacity: 0;
            visibility: hidden;
            transform: translateX(100%);
            display: flex; /* 始终启用Flexbox */
            flex-direction: column;
            z-index: 10;
        }
        .log-container.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }
        .log-header {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #e2e8f0;
        }
        .log-messages {
            flex-grow: 1;
            overflow-y: auto;
            font-size: 0.875rem;
            line-height: 1.5;
            color: #cbd5e0;
            background-color: #1a202c;
            padding: 0.5rem;
            border-radius: 0.25rem;
        }
        .log-message {
            margin-bottom: 0.5rem;
            padding: 0.25rem;
            border-bottom: 1px solid #4a5568;
        }
        .log-message.error {
            color: #fc8181;
        }
        .log-message.warning {
            color: #fbd38d; /* 添加警告用的颜色 */
        }
        .log-toggle-button {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 11; /* 在日志容器前面显示 */
        }

        .action-buttons {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">

    <button id="logToggleButton" class="log-toggle-button custom-file-upload">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2h1v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
        </svg>
        日志显示
    </button>

    <div id="logContainer" class="log-container">
        <div class="log-header">日志</div>
        <div id="logMessages" class="log-messages"></div>
    </div>

    <div class="main-container">
        <h1 class="text-3xl font-bold mb-6 text-blue-400">高性能波形生成器 v2.00</h1>
        
        <div class="flex flex-col items-center space-y-4 w-full max-w-md">
            <label for="audioFile" class="custom-file-upload">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-4 4 4 4-4V5h-2a1 1 0 100 2h2v3l-3 3-4-4-4 4z" clip-rule="evenodd" />
                </svg>
                选择音频文件
            </label>
            <input type="file" id="audioFile" accept="audio/mpeg, audio/wav, .mp3, .wav, .aac, .flac, .ogg, .aiff, .m4a, .amr, .opus, .pcm" class="rounded-md p-2 bg-gray-700 text-gray-100 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <audio id="audioPlayer" controls class="rounded-md shadow-lg"></audio>
            
            <div class="w-full flex flex-col items-center space-y-2">
                <div class="action-buttons">
                    <button id="recordStartButton" class="custom-file-upload" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                        </svg>
                        开始记录
                    </button>
                    <button id="saveBarHeightsButton" class="custom-file-upload" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10 2a8 8 0 100 16 8 8 0 000-16zm-3.293 9.293a1 1 0 011.414 0L9 12.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414z" />
                        </svg>
                        保存
                    </button>
                </div>
                <div class="flex flex-col items-start w-full mt-4 p-3 bg-gray-700 rounded-md">
                    <label class="text-sm font-semibold mb-2 text-gray-300">记录方式:</label>
                    <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
                        <label class="inline-flex items-center">
                            <input type="radio" name="recordFormat" value="waveform" class="form-radio text-blue-500" checked>
                            <span class="ml-2 text-gray-100">波形数据 (.txt)</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="recordFormat" value="sb3" class="form-radio text-blue-500">
                            <span class="ml-2 text-gray-100">.记录为.sb3格式 (scratch)</span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    
        <canvas id="audioSpectrum" class="rounded-lg shadow-xl"></canvas>
    
        <div class="settings-container w-full max-w-md p-4 bg-gray-800 rounded-lg shadow-lg mt-6">
            <h2 class="text-xl font-semibold mb-4 text-blue-300">设定</h2>
    
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div class="setting-item">
                    <label for="minFreqInput">最小频率 (Hz):</label>
                    <input type="number" id="minFreqInput" value="20" min="0" step="1">
                </div>
    
                <div class="setting-item">
                    <label for="maxFreqInput">最大频率 (Hz):</label>
                    <input type="number" id="maxFreqInput" value="24000" min="0" step="1">
                </div>
    
                <div class="setting-item">
                    <label for="numBarsInput">条数:</label>
                    <input type="number" id="numBarsInput" value="480" min="0" step="1">
                </div>
    
                <div class="setting-item">
                    <label for="barThicknessInput">棒的粗细 (Bar Thickness):</label>
                    <input type="number" id="barThicknessInput" value="5" min="0" step="1">
                </div>
    
                <div class="setting-item">
                    <label for="barHeightScaleInput">条形的高度:</label>
                    <input type="number" id="barHeightScaleInput" value="0.5" min="0" step="0.1">
                </div>
    
                <div class="setting-item">
                    <label for="attackInput">攻击 (Attack):</label>
                    <input type="number" id="attackInput" value="0.6" min="0" step="0.01">
                </div>
    
                <div class="setting-item">
                    <label for="decayInput">破坏 (Decay):</label>
                    <input type="number" id="decayInput" value="0.6" min="0" step="0.01">
                </div>
    
                <div class="setting-item">
                    <label for="peakBrightnessInput">峰值亮度 (Peak Brightness):</label>
                    <input type="number" id="peakBrightnessInput" value="1.0" min="0" step="0.1">
                </div>
    
                <div class="setting-item">
                    <label for="smoothCurveInput">平滑曲线 (Smooth Curve):</label>
                    <input type="number" id="smoothCurveInput" value="2.5" min="0" step="0.1">
                </div>
    
                <div class="setting-item">
                    <label for="freqCompensationInput">频率校正 (0-2):</label>
                    <input type="number" id="freqCompensationInput" value="2" min="0" step="0.1">
                </div>
    
                <div class="setting-item">
                    <label for="fpsInput">作品的FPS:</label>
                    <input type="number" id="fpsInput" value="60" min="1" step="1">
                </div>
                
                <div class="setting-item">
                    <label for="intervalInput">采样间隔 (n/1):</label>
                    <input type="number" id="intervalInput" value="2" min="1" step="1">
                </div>
    
                <div class="setting-item">
                    <label for="colorPickerInput">图形颜色:</label>
                    <input type="color" id="colorPickerInput" value="#ff3165"> <!-- Default Deep Sky Blue -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get references to HTML elements
        const audioFile = document.getElementById('audioFile');
        const audioPlayer = document.getElementById('audioPlayer');
        const canvas = document.getElementById('audioSpectrum');
        const ctx = canvas.getContext('2d');
        const saveBarHeightsButton = document.getElementById('saveBarHeightsButton');
        const recordStartButton = document.getElementById('recordStartButton'); // New button
        const recordFormatWaveform = document.querySelector('input[name="recordFormat"][value="waveform"]');
        const recordFormatSb3 = document.querySelector('input[name="recordFormat"][value="sb3"]');
        const logToggleButton = document.getElementById('logToggleButton');
        const logContainer = document.getElementById('logContainer');
        const logMessages = document.getElementById('logMessages');

        // References to setting input elements
        const minFreqInput = document.getElementById('minFreqInput');
        const maxFreqInput = document.getElementById('maxFreqInput');
        const numBarsInput = document.getElementById('numBarsInput');
        const barThicknessInput = document.getElementById('barThicknessInput');
        const barHeightScaleInput = document.getElementById('barHeightScaleInput');
        const attackInput = document.getElementById('attackInput');
        const decayInput = document.getElementById('decayInput');
        const peakBrightnessInput = document.getElementById('peakBrightnessInput');
        const colorPickerInput = document.getElementById('colorPickerInput'); 
        const smoothCurveInput = document.getElementById('smoothCurveInput');
        const freqCompensationInput = document.getElementById('freqCompensationInput');
        const fpsInput = document.getElementById('fpsInput'); 
        const intervalInput = document.getElementById('intervalInput'); // New interval input

        // Initialize AudioContext and AnalyserNode
        let audioContext;
        let analyser;
        let source;
        let dataArray;
        let bufferLength;

        // Initial values for settings variables (will be updated by updateSettings)
        let minFrequency;
        let maxFrequency;
        let numBars;
        let barThickness;
        let barHeightScale;
        let attackTimeConstant;
        let decayTimeConstant;
        let peakBrightnessScale;
        let currentHue;
        let smoothCurve;
        let freqCompensation; 
        let targetFPS; 
        let lastFrameTime = 0; // For FPS control

        // 添加记录相关变量
        let audioStartTime = 0;
        let lastRecordedAudioTime = 0;
        let recordedFrameCountForLog = 0;
        let lastLogTime = 0;

        // Array to hold smoothed display data
        let smoothedDisplayData;
        // Array to store recorded bar heights
        let recordedBarHeights = [];
        let isRecording = false;
        let recordingInterval = null; // 记录用的间隔计时器

        // Function to log messages to the sidebar
        function logMessage(message, type = 'info') {
            const messageElement = document.createElement('div');
            messageElement.className = 'log-message';
            if (type === 'error') {
                messageElement.classList.add('error');
            } else if (type === 'warning') {
                messageElement.classList.add('warning');
            }
            messageElement.textContent = message;
            logMessages.prepend(messageElement); // Add to the top
        }

        // Helper function to convert Hex to HSL
        // H in HSL is 0-360, S and L are 0-100
        function hexToHsl(hex) {
            let r = 0, g = 0, b = 0;
            // Parse 3-digit or 6-digit HEX format
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }

            r /= 255;
            g /= 255;
            b /= 255;

            let max = Math.max(r, g, b);
            let min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // Grayscale
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [h * 360, s * 100, l * 100];
        }

        // Function to update all settings variables from input fields
        function updateSettings() {
            minFrequency = parseFloat(minFreqInput.value);
            maxFrequency = parseFloat(maxFreqInput.value);
            numBars = parseInt(numBarsInput.value);
            barThickness = parseInt(barThicknessInput.value);
            barHeightScale = parseFloat(barHeightScaleInput.value);
            attackTimeConstant = parseFloat(attackInput.value);
            decayTimeConstant = parseFloat(decayInput.value);
            peakBrightnessScale = parseFloat(peakBrightnessInput.value);
            smoothCurve = parseFloat(smoothCurveInput.value);
            freqCompensation = parseFloat(freqCompensationInput.value);
            targetFPS = parseInt(fpsInput.value);
            
            // Update currentHue from color picker
            const hsl = hexToHsl(colorPickerInput.value);
            currentHue = hsl[0];

            // Re-initialize smoothedDisplayData if numBars changes
            if (!smoothedDisplayData || smoothedDisplayData.length !== numBars * 4) {
                smoothedDisplayData = new Uint8Array(numBars * 4).fill(0);
            }
        }

        // Function to initialize AudioContext
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 8192; // Set FFT size to 8192 (precision)
                bufferLength = analyser.frequencyBinCount; // Length of data array (fftSize / 2)
                dataArray = new Uint8Array(bufferLength); // Array to store frequency data
                analyser.smoothingTimeConstant = 0; // Disable internal smoothing

                // Connect audio element as source
                source = audioContext.createMediaElementSource(audioPlayer);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
            }
        }

        // Function to process recorded bar heights into the final string format
        function processRecordedBarHeights(heights) {
            // This function now returns a flat array of strings, each representing a single processed bar height
            // This is suitable for direct insertion into a Scratch list.
            const processedFrames = [];
            const interval = parseInt(intervalInput.value, 10) || 1; // Use value from new interval input

            for (const frame of heights) {
                const processedBarValues = [];
                for (let i = 0; i < frame.length; i++) {
                    if (i % interval === 0) { // Apply sampling interval
                        const height = frame[i];
                        const cappedHeight = Math.min(height, 315);
                        const number = Math.floor(cappedHeight / 2);
                        const result = Math.min(Math.round(number / 3), 52); // Ensure result does not exceed 52

                        if (result === 0) {
                            processedBarValues.push('"');
                        } else if (result === 1) {
                            processedBarValues.push('#');
                        } else if (result === 2) {
                            processedBarValues.push('$');
                        } else if (result === 3) {
                            processedBarValues.push('%');
                        } else if (result === 4) {
                            processedBarValues.push('&');
                        } else if (result === 5) {
                            processedBarValues.push("'");
                        } else if (result === 6) {
                            processedBarValues.push('(');
                        } else if (result === 7) {
                            processedBarValues.push(')');
                        } else if (result === 8) {
                            processedBarValues.push('=');
                        } else if (result === 9) {
                            processedBarValues.push('^');
                        } else if (result === 10) {
                            processedBarValues.push('!');
                        } else if (result >= 11 && result <= 36) {
                            processedBarValues.push(String.fromCharCode(96 + result - 10));
                        } else if (result >= 37 && result <= 52) {
                            processedBarValues.push(String.fromCharCode(64 + result - 36));
                        }
                    }
                }
                // Join all processed bar values for this frame into a single string
                processedFrames.push(processedBarValues.join(''));
            }

            // Filter out lines that are entirely double quotes
            return processedFrames.filter(line => !(/^"+$/.test(line.trim())));
        }


        // Function to perform the saving logic
        async function performSave() {
            const selectedFormat = document.querySelector('input[name="recordFormat"]:checked').value;

            if (recordedBarHeights.length === 0) {
                logMessage("没有保存的波形数据。", 'warning'); // Change to warning
                return;
            }

            const processedDataArray = processRecordedBarHeights(recordedBarHeights); // This now returns an array of strings

            if (selectedFormat === 'waveform') {
                // Get current settings for the header
                const settingsHeader = `?,${numBars},${barThickness},${barHeightScale},${targetFPS},${colorPickerInput.value}`;
                const finalOutput = settingsHeader + '\n' + processedDataArray.join('\n'); // Join array elements with newline for .txt

                // 将最终结果下载为文本文件
                const blob = new Blob([finalOutput], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'spectrum_data.txt';
                a.click();
                URL.revokeObjectURL(url);
                logMessage("将波形数据保存为.txt。");
            } else if (selectedFormat === 'sb3') {
                if (!baseSb3Content) {
                    logMessage("基于的.sb3尚未加载", 'error');
                    return;
                }
                if (!selectedAudioFile) {
                    logMessage("音源文件未选择。", 'error');
                    return;
                }

                // Load the base SB3 file as a Blob
                const baseSb3Blob = new Blob([baseSb3Content], { type: 'application/x.scratch.sb3' });

                // Use JSZip to modify the SB3 file
                const jszipModule = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
                // Try to get the JSZip constructor from different possible export patterns
                const JSZip = jszipModule.default || jszipModule.JSZip || window.JSZip;

                if (!JSZip || typeof JSZip.loadAsync !== 'function') {
                    logMessage("加载JSZip库失败。无法以.sb3的格式保存。", 'error');
                    console.error("JSZip library not properly loaded or does not have loadAsync method.");
                    return;
                }

                const zip = await JSZip.loadAsync(baseSb3Blob);

                // Modify project.json to include the new list data
                let projectJsonString = await zip.file('project.json').async('text');
                
                // Replace "音源" with the selected audio file's original name
                projectJsonString = projectJsonString.replace(/音源/g, selectedAudioFile.name);
                
                const projectJson = JSON.parse(projectJsonString);

                // Find the Stage target (isStage: true)
                const stageTarget = projectJson.targets.find(target => target.isStage === true);

                if (stageTarget) {
                    // Ensure lists object exists on the stage target
                    if (!stageTarget.lists) {
                        stageTarget.lists = {};
                    }

                    // Find or create a list variable. Use the specified list name "#频谱数据"
                    let spectrumListId = Object.keys(stageTarget.lists).find(key => stageTarget.lists[key][0] === "#频谱数据");

                    // Fallback UUID generator if JSZip.utils.generateUUID is not available
                    const generateUUID = (JSZip.utils && typeof JSZip.utils.generateUUID === 'function') ?
                                         JSZip.utils.generateUUID :
                                         () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                                             var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                                             return v.toString(16);
                                         });

                    if (!spectrumListId) {
                        // If "#频谱数据" list doesn't exist, create it
                        spectrumListId = generateUUID(); // Use the robust UUID generator
                        stageTarget.lists[spectrumListId] = ["#频谱数据", []]; // Target the stage's lists
                    }
                    
                    // Clear existing list data and add new data
                    // Construct the settings header as a single string
                    const settingsHeader = `?,${numBars},${barThickness},${barHeightScale},${targetFPS},${colorPickerInput.value}`;
                    
                    // Add the settings header to the beginning of the processed data array
                    processedDataArray.unshift(settingsHeader);

                    stageTarget.lists[spectrumListId][1] = processedDataArray; // Assign the array directly to the list
                    
                } else {
                    logMessage("找不到 Scratch项目的舞台目标。", 'error');
                    return;
                }

                // Update project.json in the zip (single line for lightweight)
                zip.file('project.json', JSON.stringify(projectJson)); // Removed null, 2 for lightweight

                // Add the selected audio file to the SB3 with the specified filename
                const audioBuffer = await selectedAudioFile.arrayBuffer();
                zip.file('663a96719183b9aa6e9c010d161487c5.mp3', audioBuffer);

                // Generate the new SB3 file
                const newSb3Blob = await zip.generateAsync({ type: 'blob' });

                // Download the new SB3 file
                const url = URL.createObjectURL(newSb3Blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'audio_spectrum.sb3';
                a.click();
                URL.revokeObjectURL(url);
                logMessage("已将波形数据保存为 audio_spectrum.sb3。");
            }
        }

        // Handle file selection
        audioFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                selectedAudioFile = file;
                const fileURL = URL.createObjectURL(file);
                audioPlayer.src = fileURL;
                audioPlayer.load();

                audioPlayer.addEventListener('loadedmetadata', () => {
                    initAudioContext();
                    recordStartButton.disabled = false;
                    saveBarHeightsButton.disabled = false;
                    requestAnimationFrame(drawSpectrum); // 波形表示开始
                }, { once: true });
            } else {
                selectedAudioFile = null;
                recordStartButton.disabled = true;
                saveBarHeightsButton.disabled = true;
                audioPlayer.src = "";
            }
        });

        // Start spectrum drawing when audio is played
        audioPlayer.addEventListener('play', () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        });

        // Function to resize canvas to window.
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        // Resize canvas on window resize
        window.addEventListener('resize', resizeCanvas);
        
        // Initial setup on window load
        window.onload = async () => {
            resizeCanvas();
            updateSettings(); // Apply initial settings from input fields

            // Fetch the base .sb3 file on page load
            try {
                // Modified URL to use raw.githubusercontent.com for direct access
                const response = await fetch('https://github.com/Leersxie/AudioSpectrum-Chinese/raw/refs/heads/main/%E6%A8%A1%E6%9D%BF.sb3');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                baseSb3Content = await response.arrayBuffer();
                logMessage('.sb3加载完成。');
            } catch (error) {
                console.error('Error loading 模板.sb3:', error);
                logMessage("加载基础的.sb3 文件失败。无法以.sb3格式保存。", 'error');
                recordFormatSb3.disabled = true; // Disable SB3 option if load fails
                recordFormatSb3.nextElementSibling.classList.add('text-gray-400'); // Gray out the label
            }
        };

        // Event listeners for setting inputs
        minFreqInput.addEventListener('input', updateSettings);
        maxFreqInput.addEventListener('input', updateSettings);
        numBarsInput.addEventListener('input', updateSettings);
        barThicknessInput.addEventListener('input', updateSettings);
        barHeightScaleInput.addEventListener('input', updateSettings);
        attackInput.addEventListener('input', updateSettings);
        decayInput.addEventListener('input', updateSettings);
        peakBrightnessInput.addEventListener('input', updateSettings);
        smoothCurveInput.addEventListener('input', updateSettings);
        freqCompensationInput.addEventListener('input', updateSettings);
        fpsInput.addEventListener('input', updateSettings);
        intervalInput.addEventListener('input', updateSettings); 
        colorPickerInput.addEventListener('input', updateSettings); 

        // Function to draw the spectrum
        function drawSpectrum(currentTime) {
            requestAnimationFrame(drawSpectrum); 

            // Control FPS
            const deltaTime = currentTime - lastFrameTime;
            const interval = 1000 / targetFPS; 

            if (deltaTime < interval) {
                return; 
            }

            lastFrameTime = currentTime - (deltaTime % interval); 

            if (!analyser) return; 

            analyser.getByteFrequencyData(dataArray); 

            ctx.clearRect(0, 0, canvas.width, canvas.height); 

            const sampleRate = audioContext.sampleRate;
            const fftSize = analyser.fftSize;

            const logMinFreq = Math.log(minFrequency);
            const logMaxFreq = Math.log(maxFrequency);
            const logRange = logMaxFreq - logMinFreq;

            const currentNumBars = numBars; 
            const spacingPerBar = canvas.width / currentNumBars; 
            const currentBarThickness = barThickness; 

            const numSmoothingPoints = currentNumBars * 4; 
            const currentFrameInterpolatedData = new Uint8Array(numSmoothingPoints);

            for (let i = 0; i < numSmoothingPoints; i++) {
                const logRatio = i / (numSmoothingPoints - 1);
                const virtualLogFreq = logMinFreq + logRatio * logRange;
                const virtualFreq = Math.exp(virtualLogFreq);

                const dataIndexFloat = virtualFreq * fftSize / sampleRate;
                const dataIndexFloor = Math.floor(dataIndexFloat);
                const dataIndexCeil = Math.ceil(dataIndexFloat);

                if (dataIndexFloor < 0 || dataIndexCeil >= bufferLength) {
                    currentFrameInterpolatedData[i] = 0;
                } else if (dataIndexFloor === dataIndexCeil) {
                    currentFrameInterpolatedData[i] = dataArray[dataIndexFloor];
                } else {
                    const val1 = dataArray[dataIndexFloor];
                    const val2 = dataArray[dataIndexCeil];
                    const fraction = dataIndexFloat - dataIndexFloor; 
                    currentFrameInterpolatedData[i] = Math.round(val1 + (val2 - val1) * fraction);
                }
            }

            // smoothedDisplayData的大小与numSmoothingPoints不同则重新初始化
            if (!smoothedDisplayData || smoothedDisplayData.length !== numSmoothingPoints) {
                smoothedDisplayData = new Uint8Array(numSmoothingPoints);
                for(let i = 0; i < numSmoothingPoints; i++) {
                    smoothedDisplayData[i] = currentFrameInterpolatedData[i];
                }
            }

            for (let i = 0; i < numSmoothingPoints; i++) {
                const targetValue = currentFrameInterpolatedData[i];
                let currentValue = smoothedDisplayData[i];

                if (targetValue > currentValue) {
                    currentValue = currentValue * attackTimeConstant + targetValue * (1 - attackTimeConstant);
                } else {
                    currentValue = currentValue * decayTimeConstant + targetValue * (1 - decayTimeConstant);
                }
                smoothedDisplayData[i] = currentValue; 
            }

            if (smoothCurve > 0) {
                const tempSmoothedData = new Uint8Array(numSmoothingPoints);
                const smoothingWindow = Math.min(Math.round(smoothCurve * 10), Math.floor(numSmoothingPoints / 2)); 
                const halfWindow = Math.floor(smoothingWindow / 2);

                for (let i = 0; i < numSmoothingPoints; i++) {
                    let sum = 0;
                    let count = 0;
                    for (let j = -halfWindow; j <= halfWindow; j++) {
                        const idx = i + j;
                        if (idx >= 0 && idx < numSmoothingPoints) {
                            sum += smoothedDisplayData[idx];
                            count++;
                        }
                        }
                    tempSmoothedData[i] = sum / count;
                }
                const blendFactor = Math.min(1, smoothCurve / 3); 
                for (let i = 0; i < numSmoothingPoints; i++) {
                    smoothedDisplayData[i] = smoothedDisplayData[i] * (1 - blendFactor) + 
                                             tempSmoothedData[i] * blendFactor;
                }
            }

            // Array to store current frame's bar heights for recording
            const currentFrameBarHeights = [];

            for (let i = 0; i < currentNumBars; i++) {
                const smoothingPointStart = Math.floor((i / currentNumBars) * numSmoothingPoints);
                const smoothingPointEnd = Math.ceil(((i + 1) / currentNumBars) * numSmoothingPoints);

                let sum = 0;
                let count = 0;
                for (let j = smoothingPointStart; j < smoothingPointEnd; j++) {
                    if (j >= 0 && j < numSmoothingPoints) {
                        sum += smoothedDisplayData[j];
                        count++;
                    }
                }

                let barHeight = count > 0 ? (sum / count) * barHeightScale : 0;

                if (freqCompensation > 0) {
                    const freqPosition = i / (currentNumBars - 1);
                    barHeight *= 1 + (freqPosition * freqCompensation);
                }

                const x = i * spacingPerBar + (spacingPerBar - currentBarThickness) / 2;

                const normalizedHeight = barHeight / canvas.height; 

                const midLightness = 50; 

                const minLightness = Math.max(0, midLightness * (1 - peakBrightnessScale / 2));

                let lightness = minLightness + (midLightness - minLightness) * normalizedHeight;
                
                lightness = Math.max(0, Math.min(100, lightness));

                ctx.fillStyle = `hsl(${currentHue}, 100%, ${lightness}%)`; 

                ctx.fillRect(x, canvas.height - barHeight, currentBarThickness, barHeight); 
            }

            // 记录处理更改
            if (isRecording) {
                const desiredRecordingFps = targetFPS;
                const recordingIntervalSeconds = 1 / desiredRecordingFps;
                const currentAudioTime = audioContext.currentTime;

                // 根据音频时间记录
                while (currentAudioTime >= lastRecordedAudioTime + recordingIntervalSeconds) {
                    const currentFrameBarHeights = [];
                    for (let i = 0; i < currentNumBars; i++) {
                        const smoothingPointStart = Math.floor((i / currentNumBars) * numSmoothingPoints);
                        const smoothingPointEnd = Math.ceil(((i + 1) / currentNumBars) * numSmoothingPoints);

                        let sum = 0;
                        let count = 0;
                        for (let j = smoothingPointStart; j < smoothingPointEnd; j++) {
                            if (j >= 0 && j < numSmoothingPoints) {
                                sum += smoothedDisplayData[j];
                                count++;
                            }
                        }

                        let barHeight = count > 0 ? (sum / count) * barHeightScale : 0;

                        if (freqCompensation > 0) {
                            const freqPosition = i / (currentNumBars - 1);
                            barHeight *= 1 + (freqPosition * freqCompensation);
                        }

                        currentFrameBarHeights.push(Math.floor(barHeight));
                    }
                    recordedBarHeights.push(currentFrameBarHeights);
                    recordedFrameCountForLog++;
                    lastRecordedAudioTime += recordingIntervalSeconds;
                }

                // 记录情况的日志显示（每秒）
                if (currentTime - lastLogTime >= 1000) {
                    logMessage(`记录FPS (设定值: ${desiredRecordingFps}, 实测: ${recordedFrameCountForLog} frames/sec)`);
                    recordedFrameCountForLog = 0;
                    lastLogTime = currentTime;
                }
            }
        }

        // Event listener for the "开始记录" button
        recordStartButton.addEventListener('click', () => {
            if (!audioPlayer.src) {
                logMessage("未选择音频文件。", 'error');
                return;
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const selectedFormat = document.querySelector('input[name="recordFormat"]:checked').value;

            if (selectedFormat === 'waveform' || selectedFormat === 'sb3') {
                isRecording = true;
                recordedBarHeights = [];
                audioStartTime = audioContext.currentTime;
                lastRecordedAudioTime = audioStartTime;
                recordedFrameCountForLog = 0;
                lastLogTime = performance.now();
                audioPlayer.currentTime = 0;
                audioPlayer.play();
                recordStartButton.disabled = true;
                saveBarHeightsButton.disabled = true;
            }
        });

        // Stop recording when audio is paused
        audioPlayer.addEventListener('pause', () => {
            isRecording = false;
            recordStartButton.disabled = false;
            saveBarHeightsButton.disabled = false;
            // performSave() 删除
        });

        // Stop recording and automatically save when audio ends
        audioPlayer.addEventListener('ended', () => {
            isRecording = false;
            performSave(); // 曲子结束时才自动保存
            recordStartButton.disabled = false;
            saveBarHeightsButton.disabled = false;
        });

        saveBarHeightsButton.addEventListener('click', performSave); // Manual save button calls the same function

        // Event listener for the log toggle button
        logToggleButton.addEventListener('click', () => {
            logContainer.classList.toggle('active');
        });

    </script>
</body>
</html>







