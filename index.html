<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scratch音频波形生成器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 字体应用 */
        body {
            font-family: "Inter", sans-serif;
            background-color: #1a202c; /* 深色背景 */
            color: #e2e8f0; /* 亮色文字 */
            display: flex;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            box-sizing: border-box;
            position: relative;
        }
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }
        canvas {
            background-color: #2d3748; /* 画布背景色 */
            border-radius: 0.5rem; /* 圆角 */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 阴影 */
            display: block;
            width: 100%; /* 宽度适应父元素 */
            max-width: 800px; /* 最大宽度 */
            height: 300px; /* 固定高度 */
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
        }
        input[type="file"] {
            display: none; /* 隐藏默认文件输入按钮 */
        }
        .custom-file-upload {
            background-color: #4a5568; /* 按钮背景色 */
            color: #e2e8f0; /* 按钮文字色 */
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border: 2px solid #6b7280; /* 按钮边框 */
        }
        .custom-file-upload:hover {
            background-color: #6b7280; /* 悬停时背景色 */
        }
        audio {
            width: 100%;
            max-width: 800px;
            margin-top: 1rem;
            border-radius: 0.5rem;
        }
        .setting-item {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            width: 100%; /* 网格项目内占满宽度 */
        }
        .setting-item label {
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
            color: #cbd5e0;
        }
        .setting-item input[type="number"],
        .setting-item input[type="color"] { /* 颜色选择器样式 */
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            background-color: #4a5568;
            border: 1px solid #6b7280;
            color: #e2e8f0;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .setting-item input[type="number"]:focus,
        .setting-item input[type="color"]:focus {
            border-color: #63b3ed;
            box-shadow: 0 0 0 2px rgba(99, 179, 237, 0.5);
        }
        /* 颜色选择器默认内边距调整 */
        .setting-item input[type="color"] {
            padding: 0.2rem; /* 缩小以显示更大的颜色样本 */
            height: 40px; /* 确保高度 */
        }
        
        .log-container {
            width: 300px;
            background-color: #2d3748;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            margin-left: 1rem;
            position: fixed; /* 固定定位 */
            top: 1rem;
            right: 1rem;
            height: calc(100vh - 2rem);
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            opacity: 0;
            visibility: hidden;
            transform: translateX(100%);
            display: flex; /* 始终启用Flexbox */
            flex-direction: column;
            z-index: 10;
        }
        .log-container.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }
        .log-header {
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #e2e8f0;
        }
        .log-messages {
            flex-grow: 1;
            overflow-y: auto;
            font-size: 0.875rem;
            line-height: 1.5;
            color: #cbd5e0;
            background-color: #1a202c;
            padding: 0.5rem;
            border-radius: 0.25rem;
        }
        .log-message {
            margin-bottom: 0.5rem;
            padding: 0.25rem;
            border-bottom: 1px solid #4a5568;
        }
        .log-message.error {
            color: #fc8181;
        }
        .log-message.warning {
            color: #fbd38d; /* 警告颜色 */
        }
        .log-toggle-button {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 11; /* 日志容器前显示 */
        }

        .action-buttons {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">

    <button id="logToggleButton" class="log-toggle-button custom-file-upload">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2h1v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
        </svg>
        显示日志
    </button>

    <div id="logContainer" class="log-container">
        <div class="log-header">日志</div>
        <div id="logMessages" class="log-messages"></div>
    </div>

    <div class="main-container">
        <h1 class="text-3xl font-bold mb-6 text-blue-400">高性能波形生成器 v2.02</h1>
        
        <div class="flex flex-col items-center space-y-4 w-full max-w-md">
            <label for="audioFile" class="custom-file-upload">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-4 4 4 4-4V5h-2a1 1 0 100 2h2v3l-3 3-4-4-4 4z" clip-rule="evenodd" />
                </svg>
                选择音频文件
            </label>
            <input type="file" id="audioFile" accept="audio/mpeg, audio/wav, .mp3, .wav, .aac, .flac, .ogg, .aiff, .m4a, .amr, .opus, .pcm" class="rounded-md p-2 bg-gray-700 text-gray-100 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <audio id="audioPlayer" controls class="rounded-md shadow-lg"></audio>
            
            <div class="w-full flex flex-col items-center space-y-2">
                <div class="action-buttons">
                    <button id="recordStartButton" class="custom-file-upload" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                        </svg>
                        开始记录
                    </button>
                    <button id="saveBarHeightsButton" class="custom-file-upload" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10 2a8 8 0 100 16 8 8 0 000-16zm-3.293 9.293a1 1 0 011.414 0L9 12.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414z" />
                        </svg>
                        保存
                    </button>
                </div>
                <div class="flex flex-col items-start w-full mt-4 p-3 bg-gray-700 rounded-md">
                    <label class="text-sm font-semibold mb-2 text-gray-300">记录格式:</label>
                    <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
                        <label class="inline-flex items-center">
                            <input type="radio" name="recordFormat" value="waveform" class="form-radio text-blue-500" checked>
                            <span class="ml-2 text-gray-100">波形数据 (.txt)</span>
                        </label>
                        <label class="inline-flex items-center">
                            <input type="radio" name="recordFormat" value="sb3" class="form-radio text-blue-500">
                            <span class="ml-2 text-gray-100">保存为.sb3格式(Scratch)</span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    
        <canvas id="audioSpectrum" class="rounded-lg shadow-xl"></canvas>
    
        <div class="settings-container w-full max-w-md p-4 bg-gray-800 rounded-lg shadow-lg mt-6">
            <h2 class="text-xl font-semibold mb-4 text-blue-300">设置</h2>
    
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div class="setting-item">
                    <label for="minFreqInput">最小频率 (Hz):</label>
                    <input type="number" id="minFreqInput" value="20" min="0" step="1">
                </div>
    
                <div class="setting-item">
                    <label for="maxFreqInput">最大频率 (Hz):</label>
                    <input type="number" id="maxFreqInput" value="24000" min="0" step="1">
                </div>
    
                <div class="setting-item">
                    <label for="numBarsInput">频谱条数量:</label>
                    <input type="number" id="numBarsInput" value="480" min="0" step="1">
                </div>
    
                <div class="setting-item">
                    <label for="barThicknessInput">频谱条宽度:</label>
                    <input type="number" id="barThicknessInput" value="5" min="0" step="1">
                </div>
    
                <div class="setting-item">
                    <label for="barHeightScaleInput">频谱条高度比例:</label>
                    <input type="number" id="barHeightScaleInput" value="0.5" min="0" step="0.1">
                </div>
    
                <div class="setting-item">
                    <label for="attackInput">上升速度:</label>
                    <input type="number" id="attackInput" value="0.6" min="0" step="0.01">
                </div>
    
                <div class="setting-item">
                    <label for="decayInput">下降速度:</label>
                    <input type="number" id="decayInput" value="0.6" min="0" step="0.01">
                </div>
    
                <div class="setting-item">
                    <label for="peakBrightnessInput">峰值亮度:</label>
                    <input type="number" id="peakBrightnessInput" value="1.0" min="0" step="0.1">
                </div>
    
                <div class="setting-item">
                    <label for="smoothCurveInput">平滑度:</label>
                    <input type="number" id="smoothCurveInput" value="2.5" min="0" step="0.1">
                </div>
    
                <div class="setting-item">
                    <label for="freqCompensationInput">频率补偿 (0-2):</label>
                    <input type="number" id="freqCompensationInput" value="2" min="0" step="0.1">
                </div>
    
                <div class="setting-item">
                    <label for="fpsInput">绘制FPS:</label>
                    <input type="number" id="fpsInput" value="60" min="1" step="1">
                </div>
                
                <div class="setting-item">
                    <label for="intervalInput">采样间隔 (每n个取1个):</label>
                    <input type="number" id="intervalInput" value="2" min="1" step="1">
                </div>
    
                <div class="setting-item">
                    <label for="colorPickerInput">频谱条颜色:</label>
                    <input type="color" id="colorPickerInput" value="#ff3165"> <!-- 默认深天蓝色 -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // 获取HTML元素引用
        const audioFile = document.getElementById('audioFile');
        const audioPlayer = document.getElementById('audioPlayer');
        const canvas = document.getElementById('audioSpectrum');
        const ctx = canvas.getContext('2d');
        const saveBarHeightsButton = document.getElementById('saveBarHeightsButton');
        const recordStartButton = document.getElementById('recordStartButton'); // 新按钮
        const recordFormatWaveform = document.querySelector('input[name="recordFormat"][value="waveform"]');
        const recordFormatSb3 = document.querySelector('input[name="recordFormat"][value="sb3"]');
        const logToggleButton = document.getElementById('logToggleButton');
        const logContainer = document.getElementById('logContainer');
        const logMessages = document.getElementById('logMessages');

        // 设置输入元素引用
        const minFreqInput = document.getElementById('minFreqInput');
        const maxFreqInput = document.getElementById('maxFreqInput');
        const numBarsInput = document.getElementById('numBarsInput');
        const barThicknessInput = document.getElementById('barThicknessInput');
        const barHeightScaleInput = document.getElementById('barHeightScaleInput');
        const attackInput = document.getElementById('attackInput');
        const decayInput = document.getElementById('decayInput');
        const peakBrightnessInput = document.getElementById('peakBrightnessInput');
        const colorPickerInput = document.getElementById('colorPickerInput'); 
        const smoothCurveInput = document.getElementById('smoothCurveInput');
        const freqCompensationInput = document.getElementById('freqCompensationInput');
        const fpsInput = document.getElementById('fpsInput'); 
        const intervalInput = document.getElementById('intervalInput'); // 新的间隔输入

        // 初始化AudioContext和AnalyserNode
        let audioContext;
        let analyser;
        let source;
        let dataArray;
        let bufferLength;

        // 设置变量的初始值（将由updateSettings更新）
        let minFrequency;
        let maxFrequency;
        let numBars;
        let barThickness;
        let barHeightScale;
        let attackTimeConstant;
        let decayTimeConstant;
        let peakBrightnessScale;
        let currentHue;
        let smoothCurve;
        let freqCompensation; 
        let targetFPS; 
        let lastFrameTime = 0; // 用于FPS控制

        // 记录相关变量
        let audioStartTime = 0;
        let lastRecordedAudioTime = 0;
        let recordedFrameCountForLog = 0;
        let lastLogTime = 0;

        // 存储平滑显示数据的数组
        let smoothedDisplayData;
        // 存储记录的频谱条高度的数组
        let recordedBarHeights = [];
        let isRecording = false;
        let recordingInterval = null; // 记录用间隔计时器

        // 将消息记录到侧边栏的函数
        function logMessage(message, type = 'info') {
            const messageElement = document.createElement('div');
            messageElement.className = 'log-message';
            if (type === 'error') {
                messageElement.classList.add('error');
            } else if (type === 'warning') {
                messageElement.classList.add('warning');
            }
            messageElement.textContent = message;
            logMessages.prepend(messageElement); // 添加到顶部
        }

        // 十六进制转HSL的辅助函数
        // HSL中的H为0-360，S和L为0-100
        function hexToHsl(hex) {
            let r = 0, g = 0, b = 0;
            // 解析3位或6位十六进制格式
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }

            r /= 255;
            g /= 255;
            b /= 255;

            let max = Math.max(r, g, b);
            let min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // 灰度
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return [h * 360, s * 100, l * 100];
        }

        // 从输入字段更新所有设置变量的函数
        function updateSettings() {
            minFrequency = parseFloat(minFreqInput.value);
            maxFrequency = parseFloat(maxFreqInput.value);
            numBars = parseInt(numBarsInput.value);
            barThickness = parseInt(barThicknessInput.value);
            barHeightScale = parseFloat(barHeightScaleInput.value);
            attackTimeConstant = parseFloat(attackInput.value);
            decayTimeConstant = parseFloat(decayInput.value);
            peakBrightnessScale = parseFloat(peakBrightnessInput.value);
            smoothCurve = parseFloat(smoothCurveInput.value);
            freqCompensation = parseFloat(freqCompensationInput.value);
            targetFPS = parseInt(fpsInput.value);
            
            // 从颜色选择器更新currentHue
            const hsl = hexToHsl(colorPickerInput.value);
            currentHue = hsl[0];

            // 如果numBars改变，重新初始化smoothedDisplayData
            if (!smoothedDisplayData || smoothedDisplayData.length !== numBars * 4) {
                smoothedDisplayData = new Uint8Array(numBars * 4).fill(0);
            }
        }

        // 初始化AudioContext的函数
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 8192; // 设置FFT大小为8192（精度）
                bufferLength = analyser.frequencyBinCount; // 数据数组长度（fftSize / 2）
                dataArray = new Uint8Array(bufferLength); // 存储频率数据的数组
                analyser.smoothingTimeConstant = 0; // 禁用内部平滑

                // 将音频元素作为源连接
                source = audioContext.createMediaElementSource(audioPlayer);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
            }
        }

        // 将记录的频谱条高度处理为最终字符串格式的函数
        function processRecordedBarHeights(heights) {
    // 此函数现在返回一个字符串数组，每个字符串代表单个处理后的频谱条高度
    // 这适合直接插入到Scratch列表中。
    const processedFrames = [];
    const interval = parseInt(intervalInput.value, 10) || 1; // 使用新间隔输入的值

    for (const frame of heights) {
        const processedBarValues = [];
        for (let i = 0; i < frame.length; i++) {
            if (i % interval === 0) { // 应用采样间隔
                const height = frame[i];
                const cappedHeight = Math.min(height, 315);
                const number = Math.floor(cappedHeight / 2);
                const result = Math.min(Math.round(number / 3), 52); // 确保结果不超过52

                if (result === 0) {
                    processedBarValues.push('"');
                } else if (result === 1) {
                    processedBarValues.push('#');
                } else if (result === 2) {
                    processedBarValues.push('$');
                } else if (result === 3) {
                    processedBarValues.push('%');
                } else if (result === 4) {
                    processedBarValues.push('&');
                } else if (result === 5) {
                    processedBarValues.push("'");
                } else if (result === 6) {
                    processedBarValues.push('(');
                } else if (result === 7) {
                    processedBarValues.push(')');
                } else if (result === 8) {
                    processedBarValues.push('=');
                } else if (result === 9) {
                    processedBarValues.push('^');
                } else if (result === 10) {
                    processedBarValues.push('!');
                } else if (result >= 11 && result <= 36) {
                    processedBarValues.push(String.fromCharCode(96 + result - 10));
                } else if (result >= 37 && result <= 52) {
                    processedBarValues.push(String.fromCharCode(64 + result - 36));
                }
            }
        }
        // 将此帧的所有处理后频谱条值连接成单个字符串
        processedFrames.push(processedBarValues.join(''));
    }

    // 不删除完全由双引号组成的行（完全静音），
    // 而是将它们转换为空字符串，以便保留空白行/空列表项。
    return processedFrames.map(line => {
        return (/^"+$/.test(line.trim())) ? '' : line;
    });
}
        // 执行保存逻辑的函数
        async function performSave() {
            const selectedFormat = document.querySelector('input[name="recordFormat"]:checked').value;

            if (recordedBarHeights.length === 0) {
                logMessage("没有可保存的波形数据。", 'warning'); // 更改为警告
                return;
            }

            const processedDataArray = processRecordedBarHeights(recordedBarHeights); // 现在返回字符串数组

            if (selectedFormat === 'waveform') {
                // 获取当前设置用于标头
                const settingsHeader = `?,${numBars},${barThickness},${barHeightScale},${targetFPS},${colorPickerInput.value}`;
                const finalOutput = settingsHeader + '\n' + processedDataArray.join('\n'); // 用换行符连接数组元素用于.txt

                // 将最终结果下载为文本文件
                const blob = new Blob([finalOutput], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'spectrum_data.txt';
                a.click();
                URL.revokeObjectURL(url);
                logMessage("波形数据已保存为spectrum_data.txt。");
            } else if (selectedFormat === 'sb3') {
                if (!baseSb3Content) {
                    logMessage("尚未加载基础.sb3文件。", 'error');
                    return;
                }
                if (!selectedAudioFile) {
                    logMessage("未选择音源文件。", 'error');
                    return;
                }

                // 将基础SB3文件加载为Blob
                const baseSb3Blob = new Blob([baseSb3Content], { type: 'application/x.scratch.sb3' });

                // 使用JSZip修改SB3文件
                const jszipModule = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
                // 尝试从不同可能的导出模式获取JSZip构造函数
                const JSZip = jszipModule.default || jszipModule.JSZip || window.JSZip;

                if (!JSZip || typeof JSZip.loadAsync !== 'function') {
                    logMessage("JSZip库加载失败。无法以sb3格式保存。", 'error');
                    console.error("JSZip库未正确加载或没有loadAsync方法。");
                    return;
                }

                const zip = await JSZip.loadAsync(baseSb3Blob);

                // 修改project.json以包含新列表数据
                let projectJsonString = await zip.file('project.json').async('text');
                
                // 将"音源"替换为所选音频文件的原始名称
                projectJsonString = projectJsonString.replace(/音源/g, selectedAudioFile.name);
                
                const projectJson = JSON.parse(projectJsonString);

                // 查找舞台目标（isStage: true）
                const stageTarget = projectJson.targets.find(target => target.isStage === true);

                if (stageTarget) {
                    // 确保舞台目标上存在列表对象
                    if (!stageTarget.lists) {
                        stageTarget.lists = {};
                    }

                    // 查找或创建列表变量。使用指定的列表名称"##频谱数据"
                    let spectrumListId = Object.keys(stageTarget.lists).find(key => stageTarget.lists[key][0] === "#频谱数据");

                    // 如果JSZip.utils.generateUUID不可用，则回退UUID生成器
                    const generateUUID = (JSZip.utils && typeof JSZip.utils.generateUUID === 'function') ?
                                         JSZip.utils.generateUUID :
                                         () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                                             var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                                             return v.toString(16);
                                         });

                    if (!spectrumListId) {
                        // 如果"#频谱数据"列表不存在，则创建它
                        spectrumListId = generateUUID(); // 使用健壮的UUID生成器
                        stageTarget.lists[spectrumListId] = ["#频谱数据", []]; // 目标为舞台的列表
                    }
                    
                    // 清除现有列表数据并添加新数据
                    // 将设置标头构造为单个字符串
                    const settingsHeader = `?,${numBars},${barThickness},${barHeightScale},${targetFPS},${colorPickerInput.value}`;
                    
                    // 将设置标头添加到处理数据数组的开头
                    processedDataArray.unshift(settingsHeader);

                    stageTarget.lists[spectrumListId][1] = processedDataArray; // 直接将数组分配给列表
                    
                } else {
                    logMessage("未找到Scratch项目的舞台目标。", 'error');
                    return;
                }

                // 在zip中更新project.json（单行用于轻量级）
                zip.file('project.json', JSON.stringify(projectJson)); // 为轻量级移除了null, 2

                // 将所选音频文件添加到具有指定文件名的SB3
                const audioBuffer = await selectedAudioFile.arrayBuffer();
                zip.file('663a96719183b9aa6e9c010d161487c5.mp3', audioBuffer);

                // 生成新的SB3文件
                const newSb3Blob = await zip.generateAsync({ type: 'blob' });

                // 下载新的SB3文件
                const url = URL.createObjectURL(newSb3Blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'audio_spectrum.sb3';
                a.click();
                URL.revokeObjectURL(url);
                logMessage("波形数据已保存为audio_spectrum.sb3。");
            }
        }

        // 处理文件选择
        audioFile.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                selectedAudioFile = file;
                const fileURL = URL.createObjectURL(file);
                audioPlayer.src = fileURL;
                audioPlayer.load();

                audioPlayer.addEventListener('loadedmetadata', () => {
                    initAudioContext();
                    recordStartButton.disabled = false;
                    saveBarHeightsButton.disabled = false;
                    requestAnimationFrame(drawSpectrum); // 开始波形显示
                }, { once: true });
            } else {
                selectedAudioFile = null;
                recordStartButton.disabled = true;
                saveBarHeightsButton.disabled = true;
                audioPlayer.src = "";
            }
        });

        // 播放音频时开始绘制频谱
        audioPlayer.addEventListener('play', () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        });

        // 根据窗口调整画布大小的函数
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        // 窗口调整大小时调整画布
        window.addEventListener('resize', resizeCanvas);
        
        // 窗口加载时的初始设置
        window.onload = async () => {
            resizeCanvas();
            updateSettings(); // 应用输入字段中的初始设置

            // 页面加载时获取基础.sb3文件
            try {
                // 修改URL以使用raw.githubusercontent.com直接访问
                const response = await fetch('https://raw.githubusercontent.com/Leersxie/AudioSpectrum-Chinese/main/%E6%A8%A1%E6%9D%BF.sb3');
                if (!response.ok) {
                    throw new Error(`HTTP错误! 状态: ${response.status}`);
                }
                baseSb3Content = await response.arrayBuffer();
                logMessage('.sb3加载完成。');
            } catch (error) {
                console.error('加载模板.sb3时出错:', error);
                logMessage("加载基础.sb3文件失败。无法以sb3格式保存。", 'error');
                recordFormatSb3.disabled = true; // 如果加载失败禁用SB3选项
                recordFormatSb3.nextElementSibling.classList.add('text-gray-400'); // 灰显标签
            }
        };

        // 设置输入的事件监听器
        minFreqInput.addEventListener('input', updateSettings);
        maxFreqInput.addEventListener('input', updateSettings);
        numBarsInput.addEventListener('input', updateSettings);
        barThicknessInput.addEventListener('input', updateSettings);
        barHeightScaleInput.addEventListener('input', updateSettings);
        attackInput.addEventListener('input', updateSettings);
        decayInput.addEventListener('input', updateSettings);
        peakBrightnessInput.addEventListener('input', updateSettings);
        smoothCurveInput.addEventListener('input', updateSettings);
        freqCompensationInput.addEventListener('input', updateSettings);
        fpsInput.addEventListener('input', updateSettings);
        intervalInput.addEventListener('input', updateSettings); 
        colorPickerInput.addEventListener('input', updateSettings); 

        // 绘制频谱的函数
        function drawSpectrum(currentTime) {
            requestAnimationFrame(drawSpectrum); 

            // 控制FPS
            const deltaTime = currentTime - lastFrameTime;
            const interval = 1000 / targetFPS; 

            if (deltaTime < interval) {
                return; 
            }

            lastFrameTime = currentTime - (deltaTime % interval); 

            if (!analyser) return; 

            analyser.getByteFrequencyData(dataArray); 

            ctx.clearRect(0, 0, canvas.width, canvas.height); 

            const sampleRate = audioContext.sampleRate;
            const fftSize = analyser.fftSize;

            const logMinFreq = Math.log(minFrequency);
            const logMaxFreq = Math.log(maxFrequency);
            const logRange = logMaxFreq - logMinFreq;

            const currentNumBars = numBars; 
            const spacingPerBar = canvas.width / currentNumBars; 
            const currentBarThickness = barThickness; 

            const numSmoothingPoints = currentNumBars * 4; 
            const currentFrameInterpolatedData = new Uint8Array(numSmoothingPoints);

            for (let i = 0; i < numSmoothingPoints; i++) {
                const logRatio = i / (numSmoothingPoints - 1);
                const virtualLogFreq = logMinFreq + logRatio * logRange;
                const virtualFreq = Math.exp(virtualLogFreq);

                const dataIndexFloat = virtualFreq * fftSize / sampleRate;
                const dataIndexFloor = Math.floor(dataIndexFloat);
                const dataIndexCeil = Math.ceil(dataIndexFloat);

                if (dataIndexFloor < 0 || dataIndexCeil >= bufferLength) {
                    currentFrameInterpolatedData[i] = 0;
                } else if (dataIndexFloor === dataIndexCeil) {
                    currentFrameInterpolatedData[i] = dataArray[dataIndexFloor];
                } else {
                    const val1 = dataArray[dataIndexFloor];
                    const val2 = dataArray[dataIndexCeil];
                    const fraction = dataIndexFloat - dataIndexFloor; 
                    currentFrameInterpolatedData[i] = Math.round(val1 + (val2 - val1) * fraction);
                }
            }

            // 如果smoothedDisplayData大小与numSmoothingPoints不同，则重新初始化
            if (!smoothedDisplayData || smoothedDisplayData.length !== numSmoothingPoints) {
                smoothedDisplayData = new Uint8Array(numSmoothingPoints);
                for(let i = 0; i < numSmoothingPoints; i++) {
                    smoothedDisplayData[i] = currentFrameInterpolatedData[i];
                }
            }

            for (let i = 0; i < numSmoothingPoints; i++) {
                const targetValue = currentFrameInterpolatedData[i];
                let currentValue = smoothedDisplayData[i];

                if (targetValue > currentValue) {
                    currentValue = currentValue * attackTimeConstant + targetValue * (1 - attackTimeConstant);
                } else {
                    currentValue = currentValue * decayTimeConstant + targetValue * (1 - decayTimeConstant);
                }
                smoothedDisplayData[i] = currentValue; 
            }

            if (smoothCurve > 0) {
                const tempSmoothedData = new Uint8Array(numSmoothingPoints);
                const smoothingWindow = Math.min(Math.round(smoothCurve * 10), Math.floor(numSmoothingPoints / 2)); 
                const halfWindow = Math.floor(smoothingWindow / 2);

                for (let i = 0; i < numSmoothingPoints; i++) {
                    let sum = 0;
                    let count = 0;
                    for (let j = -halfWindow; j <= halfWindow; j++) {
                        const idx = i + j;
                        if (idx >= 0 && idx < numSmoothingPoints) {
                            sum += smoothedDisplayData[idx];
                            count++;
                        }
                        }
                    tempSmoothedData[i] = sum / count;
                }
                const blendFactor = Math.min(1, smoothCurve / 3); 
                for (let i = 0; i < numSmoothingPoints; i++) {
                    smoothedDisplayData[i] = smoothedDisplayData[i] * (1 - blendFactor) + 
                                             tempSmoothedData[i] * blendFactor;
                }
            }

            // 存储当前帧频谱条高度的数组用于记录
            const currentFrameBarHeights = [];

            for (let i = 0; i < currentNumBars; i++) {
                const smoothingPointStart = Math.floor((i / currentNumBars) * numSmoothingPoints);
                const smoothingPointEnd = Math.ceil(((i + 1) / currentNumBars) * numSmoothingPoints);

                let sum = 0;
                let count = 0;
                for (let j = smoothingPointStart; j < smoothingPointEnd; j++) {
                    if (j >= 0 && j < numSmoothingPoints) {
                        sum += smoothedDisplayData[j];
                        count++;
                    }
                }

                let barHeight = count > 0 ? (sum / count) * barHeightScale : 0;

                if (freqCompensation > 0) {
                    const freqPosition = i / (currentNumBars - 1);
                    barHeight *= 1 + (freqPosition * freqCompensation);
                }

                const x = i * spacingPerBar + (spacingPerBar - currentBarThickness) / 2;

                const normalizedHeight = barHeight / canvas.height; 

                const midLightness = 50; 

                const minLightness = Math.max(0, midLightness * (1 - peakBrightnessScale / 2));

                let lightness = minLightness + (midLightness - minLightness) * normalizedHeight;
                
                lightness = Math.max(0, Math.min(100, lightness));

                ctx.fillStyle = `hsl(${currentHue}, 100%, ${lightness}%)`; 

                ctx.fillRect(x, canvas.height - barHeight, currentBarThickness, barHeight); 
            }

            // 修改记录处理
            if (isRecording) {
                const desiredRecordingFps = targetFPS;
                const recordingIntervalSeconds = 1 / desiredRecordingFps;
                const currentAudioTime = audioContext.currentTime;

                // 基于音频时间记录
                while (currentAudioTime >= lastRecordedAudioTime + recordingIntervalSeconds) {
                    const currentFrameBarHeights = [];
                    for (let i = 0; i < currentNumBars; i++) {
                        const smoothingPointStart = Math.floor((i / currentNumBars) * numSmoothingPoints);
                        const smoothingPointEnd = Math.ceil(((i + 1) / currentNumBars) * numSmoothingPoints);

                        let sum = 0;
                        let count = 0;
                        for (let j = smoothingPointStart; j < smoothingPointEnd; j++) {
                            if (j >= 0 && j < numSmoothingPoints) {
                                sum += smoothedDisplayData[j];
                                count++;
                            }
                        }

                        let barHeight = count > 0 ? (sum / count) * barHeightScale : 0;

                        if (freqCompensation > 0) {
                            const freqPosition = i / (currentNumBars - 1);
                            barHeight *= 1 + (freqPosition * freqCompensation);
                        }

                        currentFrameBarHeights.push(Math.floor(barHeight));
                    }
                    recordedBarHeights.push(currentFrameBarHeights);
                    recordedFrameCountForLog++;
                    lastRecordedAudioTime += recordingIntervalSeconds;
                }

                // 显示记录状态日志（每秒）
                if (currentTime - lastLogTime >= 1000) {
                    logMessage(`记录FPS (设置: ${desiredRecordingFps}, 实际: ${recordedFrameCountForLog} 帧/秒)`);
                    recordedFrameCountForLog = 0;
                    lastLogTime = currentTime;
                }
            }
        }

        // "开始记录"按钮的事件监听器
        recordStartButton.addEventListener('click', () => {
            if (!audioPlayer.src) {
                logMessage("未选择音频文件。", 'error');
                return;
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const selectedFormat = document.querySelector('input[name="recordFormat"]:checked').value;

            if (selectedFormat === 'waveform' || selectedFormat === 'sb3') {
                isRecording = true;
                recordedBarHeights = [];
                audioStartTime = audioContext.currentTime;
                lastRecordedAudioTime = audioStartTime;
                recordedFrameCountForLog = 0;
                lastLogTime = performance.now();
                audioPlayer.currentTime = 0;
                audioPlayer.play();
                recordStartButton.disabled = true;
                saveBarHeightsButton.disabled = true;
            }
        });

        // 音频暂停时停止记录
        audioPlayer.addEventListener('pause', () => {
            isRecording = false;
            recordStartButton.disabled = false;
            saveBarHeightsButton.disabled = false;
            // 移除performSave()
        });

        // 音频结束时停止记录并自动保存
        audioPlayer.addEventListener('ended', () => {
            isRecording = false;
            performSave(); // 仅在歌曲结束时自动保存
            recordStartButton.disabled = false;
            saveBarHeightsButton.disabled = false;
        });

        saveBarHeightsButton.addEventListener('click', performSave); // 手动保存按钮调用相同函数

        // 日志切换按钮的事件监听器
        logToggleButton.addEventListener('click', () => {
            logContainer.classList.toggle('active');
        });

    </script>
</body>
</html>
